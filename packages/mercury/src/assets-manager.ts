import {
  GxImageMultiState,
  NavigationListItemModel,
  TreeViewImagePathCallback,
  TreeViewItemModel
} from "@genexus/chameleon-controls-library";
import { RegistryGetImagePathCallback } from "@genexus/chameleon-controls-library/dist/types/index";
import { TreeViewItemImageMultiState } from "@genexus/chameleon-controls-library/dist/types/components/tree-view/types";

import { MERCURY_ASSETS } from "./assets/MERCURY_ASSETS.js";
import { ActionListItemAdditionalBase } from "@genexus/chameleon-controls-library/dist/types/components/action-list/types.js";
// import { ComboBoxItemModel } from "@genexus/chameleon-controls-library/dist/types/components/combo-box/types.js";

export {
  MercuryBundleBase,
  MercuryBundleComponent,
  MercuryBundleComponentForm,
  MercuryBundleFull,
  MercuryBundleOptimized,
  MercuryBundleReset,
  MercuryBundleUtil,
  MercuryBundleUtilFormFull,
  MercuryBundles
} from "./bundles.js";

export { getThemeBundles, getBundles } from "./bundles.js";

const ASSETS_BY_VENDOR: { [key in string]: Assets } = {};
const ALIAS_TO_VENDOR_NAME: { [key in string]: string } = {};

const SEPARATOR = "/";
const EXPANDED_SEPARATOR = ":";
const MERCURY_ALIAS = "mer";

export type AssetsMetadata = {
  category: string;
  name: string;
  colorType?: string;
};

/**
 * For example:
 * ```
 * {
 *   icons: {
 *     objects: { // Category
 *       stencil: { // Icon Name
 *         enabled: { // State
 *           name: "objects_stencil--enabled"
 *         }
 *       },
 *     },
 *     windows-tools: { // Category
 *       workflow: { // Icon Name
 *         "on-surface": { // Color Type
 *           enabled: { // State
 *             name: "windows-tools_workflow_on-surface--enabled"
 *           },
 *           hover: {
 *             name: "windows-tools_workflow_on-surface--hover"
 *           }
 *         }
 *       }
 *     }
 *   }
 * }
 * ```
 */
export type Assets = {
  icons: { [key in string]: AssetsCategories };
};

export type AssetsCategories = { [key: string]: AssetsIconName };

export type AssetsIconName =
  | {
      [key: string]: AssetsColorType;
    }
  | AssetsColorType;

export type AssetsColorType = { [key: string]: AssetsIconMetadata };

export interface AssetsIconMetadata {
  name: string;
}

/**
 * Given a vendor and its assets, it register the assets of the vendor. After
 * the registration, the `getAsset` function can be used to retrieve any assets
 * related to the vendor.
 * @param vendorName The name of the vendor (for example, "Mercury"). Must be unique.
 * @param vendorAlias The alias of the vendor (for example, "mer"). Must be unique.
 * @param assets The assets (generated by the SVG Sass Generator) to register.
 */
export const registerAssets = (
  vendorName: string,
  vendorAlias: string,
  assets: Assets
) => {
  // Already registered
  if (ASSETS_BY_VENDOR[vendorName] || ALIAS_TO_VENDOR_NAME[vendorAlias]) {
    return;
  }

  ASSETS_BY_VENDOR[vendorName] = assets;
  ALIAS_TO_VENDOR_NAME[vendorAlias] = vendorName;
};

/**
 * @param vendorAlias The name or alias of the vendor.
 * @param assetMetadata The metadata required to retrieve the icon
 * @return The required asset or undefined if not found.
 */
export const getAsset = (
  vendorAliasOrName: string,
  assetMetadata: AssetsMetadata
): AssetsColorType | undefined => {
  const vendorName =
    ALIAS_TO_VENDOR_NAME[vendorAliasOrName] ?? vendorAliasOrName;
  const vendorAssets = ASSETS_BY_VENDOR[vendorName];

  if (!vendorAssets) {
    return undefined;
  }

  const iconCategoryObject = vendorAssets.icons[assetMetadata.category];

  // The category does not exists
  if (!iconCategoryObject) {
    return undefined;
  }
  const iconNameObject = iconCategoryObject[assetMetadata.name];

  // The name in the category does not exists
  if (!iconNameObject) {
    return undefined;
  }

  return assetMetadata.colorType
    ? (
        iconNameObject as {
          [key: string]: AssetsColorType;
        }
      )[assetMetadata.colorType]
    : (iconNameObject as AssetsColorType);
};

/**
 * Given the metadata of the icon, it transforms the metadata into a string
 * that contains the given information.
 */
export const getIconPath = (
  iconMetadata: AssetsMetadata,
  vendorAlias: string = MERCURY_ALIAS
) => {
  const additionalInfo = iconMetadata.colorType
    ? `${SEPARATOR}${iconMetadata.colorType}`
    : "";

  return `${vendorAlias}${SEPARATOR}${iconMetadata.category}${SEPARATOR}${iconMetadata.name}${additionalInfo}` as const;
};

/**
 * Given the metadata of the icon and the metadata of its expanded version, it
 * transforms both metadata into a string that contains the given information.
 */
export const getIconPathExpanded = (
  iconMetadata: AssetsMetadata,
  iconMetadataExpanded: AssetsMetadata,
  vendorAlias: string = MERCURY_ALIAS
) =>
  `${getIconPath(iconMetadata, vendorAlias)}${EXPANDED_SEPARATOR}${getIconPath(
    iconMetadataExpanded,
    vendorAlias
  )}` as const;

const getCustomFullValue = (
  iconName: string,
  vendorAliasOrName: string,
  suffix?: "enabled" | "hover" | "active" | "disabled"
) => {
  const vendorPrefix =
    vendorAliasOrName === MERCURY_ALIAS
      ? ""
      : (`-${vendorAliasOrName}` as const);

  return suffix
    ? (`var(--icon${vendorPrefix}__${iconName}--${suffix})` as const)
    : (`var(--icon${vendorPrefix}__${iconName})` as const);
};

/**
 * Parses the incoming iconMetadata, assuming Mercury as the default vendor if
 * the vendor is not specified (it is not found in the register)
 */
const parseIconMetadata = (
  iconPath: string
): {
  vendor: string;
  category: string;
  name: string;
  colorType: string | undefined;
} => {
  const iconMetadata = iconPath.split(SEPARATOR);

  const vendorAliasOrName = iconMetadata[0];

  const vendorName =
    ALIAS_TO_VENDOR_NAME[vendorAliasOrName] ?? vendorAliasOrName;
  const vendorAssets = ASSETS_BY_VENDOR[vendorName];

  // The vendor is not contained in the path, assume by default Mercury.
  if (!vendorAssets) {
    const category = iconMetadata[0]; // Assume that the first value is the category
    const name = iconMetadata[1];
    const colorType: string | undefined = iconMetadata[2];

    return {
      vendor: MERCURY_ALIAS,
      category,
      name,
      colorType: colorType
    };
  }

  const category = iconMetadata[1];
  const name = iconMetadata[2];
  const colorType: string | undefined = iconMetadata[3];

  return {
    vendor: vendorAliasOrName,
    category,
    name,
    colorType: colorType
  };
};

export const getImagePathCallback = (
  iconPath: string
): GxImageMultiState | undefined => {
  const { vendor, category, name, colorType } = parseIconMetadata(iconPath);

  const assetStates: AssetsColorType | undefined = getAsset(
    vendor,
    colorType ? { category, name, colorType } : { category, name }
  );

  if (!assetStates) {
    return undefined;
  }

  const result: GxImageMultiState = {
    base: getCustomFullValue(assetStates.enabled.name, vendor)
  };

  if (assetStates.hover) {
    result.hover = getCustomFullValue(assetStates.hover.name, vendor);
  }

  if (assetStates.active) {
    result.active = getCustomFullValue(assetStates.active.name, vendor);
  }

  if (assetStates.disabled) {
    result.disabled = getCustomFullValue(assetStates.disabled.name, vendor);
  }

  return result;
};

export const getActionListImagePathCallback = (
  additionalItem: ActionListItemAdditionalBase
) =>
  additionalItem.imgSrc
    ? getImagePathCallback(additionalItem.imgSrc)
    : undefined;

export const getNavigationListImagePathCallback = (
  itemModel: NavigationListItemModel
) =>
  itemModel.startImgSrc
    ? getImagePathCallback(itemModel.startImgSrc)
    : undefined;

export const getTreeViewImagePathCallback: TreeViewImagePathCallback = (
  item: TreeViewItemModel,
  iconDirection: "start" | "end"
): string | TreeViewItemImageMultiState | undefined => {
  if (
    (!item.startImgSrc && iconDirection === "start") ||
    (!item.endImgSrc && iconDirection === "end")
  ) {
    return undefined;
  }

  const imgSrc =
    iconDirection === "start" ? item.startImgSrc! : item.endImgSrc!;

  // Split the path into the collapsed (default) and expanded
  const collapsedAndExpandedSrc = imgSrc.split(EXPANDED_SEPARATOR);

  const defaultPath = getImagePathCallback(collapsedAndExpandedSrc[0]);

  if (!defaultPath) {
    return undefined;
  }

  // If the icon has expanded state, process the expanded state
  return collapsedAndExpandedSrc[1]
    ? {
        default: defaultPath,
        expanded: getImagePathCallback(collapsedAndExpandedSrc[1])
      }
    : { default: defaultPath };
};

// export const getComboBoxImagePathCallback: ComboBoxImagePathCallback = (
//   item: ComboBoxItemModel,
//   iconDirection: "start" | "end"
// ): GxImageMultiState | undefined => {
//   if (
//     (!item.startImgSrc && iconDirection === "start") ||
//     (!item.endImgSrc && iconDirection === "end")
//   ) {
//     return undefined;
//   }
//   const imgSrc =
//     iconDirection === "start" ? item.startImgSrc! : item.endImgSrc!;
//   return getImagePathCallback(imgSrc);
// };

/**
 * This object is used to register the getImagePathCallback definitions for all
 * controls in Chameleon.
 *
 * @example
 * ```ts
 * registryProperty("getImagePathCallback", getImagePathCallbackDefinitions);
 * ```
 */
export const getImagePathCallbackDefinitions: RegistryGetImagePathCallback = {
  "ch-accordion-render": getImagePathCallback,
  "ch-action-list-render": getActionListImagePathCallback,
  "ch-navigation-list-render": getNavigationListImagePathCallback,
  "ch-checkbox": getImagePathCallback,
  "ch-edit": getImagePathCallback,
  "ch-image": getImagePathCallback,
  "ch-tree-view-render": getTreeViewImagePathCallback
};

// Initialize Mercury at the start
registerAssets("Mercury", MERCURY_ALIAS, MERCURY_ASSETS);
